module uart #(
    parameter integer clk_per_bit = 434,
    parameter integer N = 8
)(
    input  [N-1:0] data_in,
    input          tx_start,
    input          clk,
    input          rst,          // active LOW

    input          r_bit,
    output reg     t_bit,
    output reg [N-1:0] data_out,

    output reg tx_active,
    output reg rx_active,
    output reg tx_complete,
    output reg rx_complete
);

    // States
    parameter ideal = 2'b00;
    parameter communicatioin = 2'b01;
    parameter clean_up = 2'b10;

    // TRANSMITTER 

    reg [1:0] state_tx;
    reg [N+1:0] shift_reg_t;   // start + N data + stop
    reg [15:0] counter_tx;
    reg [$clog2(N+2):0] index_tx;

    always @(posedge clk or negedge rst) begin
        if(!rst) begin
            state_tx    <= ideal;
            shift_reg_t <= 0;
            counter_tx  <= 0;
            index_tx    <= 0;
            t_bit       <= 1;
            tx_active   <= 0;
            tx_complete <= 0;
        end
        else begin
            case(state_tx)

            ideal: begin
                tx_complete <= 0;
                t_bit <= 1;

                if(tx_start) begin
                    tx_active   <= 1;
                    shift_reg_t <= {1'b1, data_in, 1'b0}; // stop,data,start
                    counter_tx  <= 0;
                    index_tx    <= 0;
                    state_tx    <= communicatioin;
                end
            end

            communicatioin: begin
                t_bit <= shift_reg_t[0];

                if(counter_tx < clk_per_bit-1)
                    counter_tx <= counter_tx + 1;
                else begin
                    counter_tx  <= 0;
                    shift_reg_t <= shift_reg_t >> 1;
                    index_tx    <= index_tx + 1;

                    if(index_tx == N+1)   // start + N data + stop
                        state_tx <= clean_up;
                end
            end

            clean_up: begin
                tx_active   <= 0;
                tx_complete <= 1;
                state_tx    <= ideal;
            end

            endcase
        end
    end

    // RECEIVER 

    reg [1:0] state_rx;
    reg [N-1:0] shift_reg_r;
    reg [15:0] counter_rx;
    reg [$clog2(N+2):0] index_rx;

    always @(posedge clk or negedge rst) begin
        if(!rst) begin
            state_rx    <= ideal;
            shift_reg_r <= 0;
            counter_rx  <= 0;
            index_rx    <= 0;
            rx_active   <= 0;
            rx_complete <= 0;
            data_out    <= 0;
        end
        else begin
            case(state_rx)

            ideal: begin
                rx_complete <= 0;

                if(r_bit == 0) begin
                    rx_active  <= 1;
                    counter_rx <= 0;
                    state_rx   <= communicatioin;
                end
            end

            communicatioin: begin

                if(counter_rx == clk_per_bit/2) begin

                    if(index_rx == 0) begin
                        // start bit (ignore)
                    end
                    else if(index_rx >= 1 && index_rx <= N) begin
                        shift_reg_r <= {r_bit, shift_reg_r[N-1:1]};
                    end

                    index_rx <= index_rx + 1;
                end

                if(counter_rx < clk_per_bit-1)
                    counter_rx <= counter_rx + 1;
                else
                    counter_rx <= 0;

                if(index_rx == N+1)   // start + N data
                    state_rx <= clean_up;
            end

            clean_up: begin
                data_out    <= shift_reg_r;
                rx_complete <= 1;
                rx_active   <= 0;
                index_rx    <= 0;
                state_rx    <= ideal;
            end

            endcase
        end
    end

endmodule
